<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nauka Informatyki poziom Rozszerzony</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
</head>
<body>

   

    <nav>
        <ul>
            <li>
                
 		
  		      <a href="../teoria.html">Kursy Python</a>
  	        
            </li>
        </ul>
    </nav>

<section>
    <ul>
        <h1><strong>1. Sortowanie: sort() i sorted():</strong></h1>
        <p>Python oferuje dwie metody do sortowania list: <code>sort()</code> i <code>sorted()</code>. Metoda <code>sort()</code> sortuje listę w miejscu (modyfikuje oryginalną listę), podczas gdy <code>sorted()</code> zwraca nową posortowaną listę, pozostawiając oryginalną listę niezmienioną.</p>
        <p>Przykład użycia <code>sort()</code>:</p>
        <pre><code>lista = [3, 1, 4, 1, 5, 9]
lista.sort()  # Sortuje w miejscu
print(lista)  </code></pre>
        <p>Przykład użycia <code>sorted()</code>:</p>
        <pre><code>lista = [3, 1, 4, 1, 5, 9]
nowa_lista = sorted(lista)  # Zwraca nową posortowaną listę
print(nowa_lista)  </code></pre>
    </ul>
</section>

<section>
    <ul>
        <h1><strong>2. Sortowanie przez scalanie i szybkie sortowanie:</strong></h1>
        <p>Sortowanie przez scalanie (merge sort) i szybkie sortowanie (quick sort) to bardziej zaawansowane algorytmy sortowania.</p>
        <h2><strong>Sortowanie przez scalanie:</strong></h2>
        <p>Sortowanie przez scalanie dzieli listę na mniejsze podlisty, sortuje je, a następnie scala w jedną posortowaną listę. Przykład implementacji:</p>
        <pre><code>def merge_sort(lista):
    if len(lista) > 1: # Sprawdza, czy lista ma więcej niż jeden element
        srodek = len(lista) // 2 # Znajduje środek listy
        lewa = lista[:srodek]  # Dzieli listę na dwie części: lewą i prawą
        prawa = lista[srodek:]

        merge_sort(lewa)
        merge_sort(prawa)

        i = j = k = 0     # Inicjalizuje wskaźniki do śledzenia aktualnej pozycji w lewym, prawym i scalanym liście

		# Scalenie dwóch posortowanych list
        while i < len(lewa) and j < len(prawa):  
# Porównuje elementy z lewego i prawego podziału
            if lewa[i] < prawa[j]:
                lista[k] = lewa[i]
                i += 1
            else:
                lista[k] = prawa[j]
                j += 1
            k += 1
# Dodaje pozostałe elementy z lewego podziału, jeśli są
        while i < len(lewa):
            lista[k] = lewa[i]
            i += 1
            k += 1
# Dodaje pozostałe elementy z prawego podziału, jeśli są
        while j < len(prawa):
            lista[k] = prawa[j]
            j += 1
            k += 1

    return lista

print(merge_sort([38, 27, 43, 3, 9, 82, 10]))</code></pre>

        <h2><strong>Szybkie sortowanie:</strong></h2>
        <p>Szybkie sortowanie dzieli listę na elementy mniejsze i większe od tzw. pivota, a następnie sortuje te części rekurencyjnie. Przykład implementacji:</p>
        <pre><code>def quick_sort(lista):
    if len(lista) <= 1:
        return lista
    pivot = lista[len(lista) // 2] # Wybiera pivot jako środkowy element listy
    lewa = [x for x in lista if x < pivot] # Tworzy listy dla elementów mniejszych, równych i większych od pivota
    srodek = [x for x in lista if x == pivot]
    prawa = [x for x in lista if x > pivot]
# Rekurencyjnie sortuje lewą i prawą część oraz łączy je z elementami równymi pivotowi
    return quick_sort(lewa) + srodek + quick_sort(prawa)

print(quick_sort([38, 27, 43, 3, 9, 82, 10]))</code></pre>
    </ul>
</section>

<section>
    <ul>
        <h1><strong>3. Wyszukiwanie binarne:</strong></h1>
        <p>Wyszukiwanie binarne to efektywny algorytm wyszukiwania w posortowanej liście, który dzieli listę na pół, aby znaleźć element. Przykład implementacji:</p>
        <pre><code>def wyszukiwanie_binarne(lista, szukany_element):
 # Ustawia początkowy lewy i prawy indeks dla przeszukiwania
    lewy = 0
    prawy = len(lista) - 1

  # Wykonuje pętlę, dopóki lewy indeks nie przekroczy prawego
    while lewy <= prawy:
	# Oblicza środkowy indeks
        srodek = (lewy + prawy) // 2

		# Sprawdza, czy środkowy element to szukany element
        if lista[srodek] == szukany_element:
            return srodek

		# Jeśli szukany element jest większy od środkowego elementu,
        # przeszukuje prawą połowę
        elif lista[srodek] < szukany_element:
            lewy = srodek + 1

		# Jeśli szukany element jest mniejszy od środkowego elementu,
        # przeszukuje lewą połowę
        else:
            prawy = srodek - 1

    # Zwraca -1, jeśli element nie został znaleziony
    return -1

lista = [1, 3, 5, 7, 9, 11]
indeks = wyszukiwanie_binarne(lista, 7)
print(indeks)</code></pre>
    </ul>
</section>

<section>
    <ul>
        <h1><strong>4. Tabele haszujące (słowniki):</strong></h1>
        <p>Tabele haszujące, znane w Pythonie jako słowniki, to struktury danych, które przechowują pary klucz-wartość. Umożliwiają szybki dostęp do wartości na podstawie klucza. Przykład użycia słownika:</p>
        <pre><code>słownik = {
    "imie": "Bartosz",
    "wiek": 23,
    "miasto": "Kielce"
}

print(słownik["imie"])  
print(słownik.get("wiek"))  # Wynik: 23

słownik["wiek"] = 24  # Aktualizowanie wartości
print(słownik["wiek"])  # Wynik: 24

del słownik["miasto"]  # Usuwanie klucza
print(słownik)  </code></pre>
    </ul>
</section>



    <footer>
        <p>Bartosz Kilarski</p>
        <p>Politechnika Świętokrzyska w Kielcach</p>
    </footer>
</body>
</html>